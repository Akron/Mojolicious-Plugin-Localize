=pod

=encoding utf8

=head1 NAME

Mojolicious::Plugin::Localize - Localization Framework for Mojolicious


=head1 SYNOPSIS

  # Register the plugin with a defined dictionary
  plugin  Localize => {
    dict => {
      name => {
        -long => 'Mojolicious',
        short => 'Mojo',
        land  => 'MojoLand'
      },
      welcome => {
        _  => sub { $_->locale },
        de => "Willkommen in <%=loc 'name_land' %>!",
        en => "Welcome to <%=loc 'name_land' %>!"
      }
    }
  };

  # Call dictionary entries from templates
  %= loc 'welcome'


=head1 DESCRIPTION

L<Mojolicious::Plugin::Localize> is a localization framework for
Mojolicious, heavily inspired by Mozilla's L<l20n|http://l20n.org/>.
Instead of being a reimplementation it uses L<Mojo::Template> for string interpolation,
L<Mojolicious::Plugin::Config> for distributed dictionaries and Mojolicious' helpers
for template functions.

B<Warning!> This is early software and behaviour may change without notifications!

=head1 METHODS

=head2 register

  app->plugin(Localize => {
    dict => {
      welcome => {
        _  => sub { $_->locale },
        de => 'Willkommen!',
        en => 'Welcome!'
      }
    },
    override  => 1,
    resources => ['french.dict', 'polish.dict']
  });

Called when registering the plugin.

Expects a parameter C<dict> containing a L<dictionary|/DICTIONARIES>.
Further dictionary files to be loaded can be passed as an array reference
using the C<resources> parameter.

The plugin can be registered multiple times, and defined dictionaries will be merged.

Already existing key definitions won't be overwritten in that way,
unless an additional C<override> parameter is set to a C<true> value.
Dictionary entries from resource files, on the other hand, will always override,
so the order of the given array is of relevance.

All parameters can be set either on registration or in a configuration file
with the key C<Localize> (loaded only on first registration).


=head1 HELPERS

In addition to the listed helpers,
L<Mojolicious::Plugin::Localize> loads further helpers by default,
see L<num|Mojolicious::Plugin::Localize::Number> and
L<locale|Mojolicious::Plugin::Localize::Locale>.


=head2 loc

  # Lookup dictionary entry from controller
  my $entry = $c->loc('welcome');

  %# Lookup dictionary entry in templates
  <%= loc 'welcome' %>

  %# Lookup and provide dictionary entries in templates
  %= loc 'welcome', begin
  %   loc_for '-en_welcome', begin
  Welcome to our site!
  %   end
  % end

Makes a dictionary lookup and returns a string.

The first parameter is the dictionary key to look up.
Optionally a C<begin> block may follow, providing several
translations directly in the template (see L<loc_for|/loc_for>).
Definitions on the dictionary structure (e.g. to define preferred and default keys)
may precede the C<begin> block.


=head2 loc_for

  %# In templates
  %= loc 'welcome', { welcome_ => sub { $_->locale } }, begin
  %   loc_for welcome_de => begin
  Herzlich willkommen auf unserer Seite, <%= stash 'user' %>!
  %   end
  %   loc_for 'welcome_-en' => begin
  Welcome to our site, <%= stash 'user' %>!
  %   end
  % end

Define dictionary entries in templates.

In case, the L<loc|/loc> helper starts a C<begin> block,
several translations may be defined directly in the template,
that are merged with the dictionary
on the first compilation of the template.

The helper expects a defined key in L<short notation|/Short Notation>
and a block containing the dictionary value.

This comes in handy for template design, so the designer knows at least
rougly the length and content of a text block to layout.
However, defining a dictionary this way is I<not recommended>,
as dictionary entries in this way are unknown on application start
(and therefore inaccessible to the C<localize> command!

B<WARNING>: Never use C<$name> stash values in C<loc_for> blocks, as they will
be compiled only once with the first rendering. Use C<stash('name')> instead!


=head2 localize

  $c->localize->locale('de');

Helper object for nested helpers.
L<Mojolicious::Plugin::Localize> loads further plugins establishing nested helpers,
see L<localize.locale|Mojolicious::Plugin::Localize::Locale>.


=head1 DICTIONARIES

=head2 Short Notation

The underscore notation can also be used to flatten nesting dictionary structures.
The following definitions are therefore equal:

  {
    welcome => {
      de => 'Willkommen!'
    }
  }

  {
    welcome_de => 'Willkommen!'
  }


=head2 Preferred Keys

The underscore is a special key, marking preferred keys on the dictionary level,
in case no matching key can be found.

  {
    welcome => {
      _ => 'en',
      de => 'Willkommen!'
      en => 'Welcome!'
    }
  }

In case the key C<welcome_de> is requested with the above dictionary established,
the value C<Willkommen!> will be returned. But if the underspecified key C<welcome>
is requested without a matching key on the final level, the preferred key C<en> will
be used instead, returning the value C<Welcome!>.

Preferred keys may contain the key as a string, a template, an array reference
of keys (in order of preference), or a subroutine returning a string or an array
reference.

  # The preferred key is 'en'
  _ => 'en'

  # The preferred key is the stash value of 'user_status' (e.g. 'mod' or 'admin')
  _ => '<%= $user_status %>'
  _ => sub { shift->stash('user_status') }

  # The preferred key is 'en', and in case this isn't defined, it's 'de'
  _ => [qw/en de/]
  _ => sub { [qw/en de/] }

The first parameter passed to subroutines is the controller object.
The local variable C<$_> is set to the L<nested helper object|/localize>,
which eases calls to, for example,
the L<locale|Mojolicious::Plugin::Localize::locale> helper.

  # The preferred key is based on the requested languages
  _ => sub { $_->locale }

Preferred keys in short notation have a trailing underscore:

  {
    greeting => {
      _ => sub { $_->locale },
      en => 'Hello!',
      de => 'Hallo!'
    }
  }
  # Set the preferred key in nested notation

  {
    greeting_ => sub { $_->locale }
    greeting_en => 'Hello!',
    greeting_de => 'Hallo!'
  }
  # Same as above in short notation


=head2 Default Keys

Default keys are marked with a leading dash symbol and can
be given in addition to preferred keys.
They will be triggered, whenever no direct access is given and no
preferred key matches.

  {
    welcome => {
      _   => 'pl',
      -en => 'Welcome!',
      de  => 'Welcome!'
    }
  }

In case the key C<welcome_de> is requested with the above dictionary established,
the value C<Willkommen!> will be returned. But if the underspecified key C<welcome>
is requested without a matching key on the final level, and the preferred key C<pl> 
isn't defined in another dictionary, the default key C<en> will be used instead,
returning the value C<Welcome!>.

To define a default key separately, use the single dash key.

  {
    welcome => {
      _   => 'pl',
      '-' => 'en',
      en  => 'Welcome!',
      de  => 'Welcome!'
    }
  }
  # This is the same dictionary entry as above

To define default keys in short notation, prepend a dash to the subkey in question.

  {
    'welcome_-en' => 'Welcome!',
    'welcome_de'  => 'Willkomen!'
  }


=head2 Backtracking

  {
    _ => [qw/de fr en/],
    de => {
      bye => 'Auf Wiedersehen!'
    },
    fr => {
      welcome => 'Bonjour!',
      bye => 'Au revoir!'
    },
    -en => {
      welcome => 'Welcome!',
      bye => 'Good bye!'
    }
  }

In case a preferred key is not found in a nested structure,
the dictionary lookup will track back default keys.

For example, if the system looks up the dictionary key C<welcome>,
there is an existing entry for the preferred key C<de> on the first level,
but the processing will stop, as no entry for C<welcome> can be found.
The system will then track back one level and choose the default key C<en>
instead. The system won't test further preferred keys.

B<BACKTRACKING IS NOT YET SUPPORTED!>


=head2 Hints and Conventions

L<Mojolicious::Plugin::Localize> let you decide, how to nest your dictionary entries.
For internationalization purposes, it is a good idea to have the language key on the first
level, so you can establish further entries relying on that structure (see, e.g., the example
snippet in L<loc|/loc>).

Dictionary keys should always be lower case.

Plugins, that provide their own dictionaries, should prefix their keys with the plugin's name,
with the first letter in upper case, to prevent clashes with other dictionary entries.
For example the welcome message for this plugin should be named C<Localize_welcome>.


=head1 AVAILABILITY

  https://github.com/Akron/Mojolicious-Plugin-Localize


=head1 COPYRIGHT AND LICENSE

Copyright (C) 2014, L<Nils Diewald|http://nils-diewald.de/>.

This program is free software, you can redistribute it
and/or modify it under the terms of the Artistic License version 2.0.

=cut
